class SaveingModItemHandler : SavingModEventHandler
{
    int has_spawned;
    int total_enemies;
    int unrolled_enemies;
    
    const SAVE_BUTTON_TICS = 35;
    int lastpress[32];

    override void UniqueWorldLoaded(WorldEvent e)
    {
        has_spawned = 0;
    }
      
    override void UniquePlayerEntered(Actor Player, bool returning)
    {
        //don't give out new items on hub maps
        if (returning)
            return;
    
        //Make sure autosaving is enabled
        if (disableautosave == 2)
        {
            String warning = Stringtable.Localize("$NOSAVE_WARNING");
            Console.MidPrint(SMALLFONT, "$NOSAVE_WARNING", true);
        }
        
        /*
        //Make sure our save button is bound
        int key = Bindings.GetKeysForCommand("nosave_quicksave");
        {
            if (key == -1)
            {
                String warning = Stringtable.Localize("$NOSAVE_NOKEY");
                Console.MidPrint(SMALLFONT, "$NOSAVE_NOKEY", true);
            }
        }
        */

        if (!Player.CheckInventory("NoSaveStartup",1))
        {
            Player.GiveInventory("NoSaveStartup",1);
        }
    }
    
    bool HasMetThreshold()
    {
        return total_enemies >= nosave_enemy_threshold - 1;
    }
    
    bool IsValidActor(Actor a)
    {
        return a && a.bISMONSTER && a.bCOUNTKILL;
    }
    
    override void NetworkProcess (ConsoleEvent e) 
    {
        if (e.Name == "SaveButton")
        {
            let player = players[e.Player].mo;
            SaveGem savegem = SaveGem(player.FindInventory("SaveGem",true));

            if (!SaveGem)
                return;

            //we have double tapped (or single tapped, if not enabled)
            if (!nosave_double_tap || (lastpress[e.Player] <= gametic && gametic - lastpress[e.Player] <= SAVE_BUTTON_TICS && lastpress[e.Player] > SAVE_BUTTON_TICS))
            {
                player.UseInventory(savegem);
            }
            else
            {
                savegem.DisplayCornerMessage(true);
            }
            
            SSDebug.LogVerbose("lastpress is "..lastpress[e.Player]..", gametic is "..gametic.."");
            lastpress[e.Player] = gametic;
        }
    }
    
    override void WorldThingSpawned(WorldEvent e)
    {
        if (IsValidActor(e.Thing))
        {
            total_enemies++;
            unrolled_enemies++;
        }
    }
    
    bool IsValidMap()
    {
        return (nosave_map_skip == 0 || level.LevelNum % nosave_map_skip == 0)
			&& (level.LevelNum >= nosave_map_first);
    }
    
    int GetSpawnsRemaining()
    {
        return nosave_items_per_level - has_spawned;
    }
    
    override void WorldThingDied(WorldEvent e)
    {
        Actor a = e.Thing;
        
        if (IsValidActor(a))
        {
            unrolled_enemies--;
            if (HasMetThreshold() && IsValidMap() && GetSpawnsRemaining() > 0 )
            {
                int droproll = random(0, unrolled_enemies);
                
                SSDebug.LogVerbose("Rolling between 0 and "..unrolled_enemies.." - rolled a "..droproll.."");
                
                if (droproll == 1)
                {
                    a.A_DropItem("SaveGem");
                    has_spawned++;
                }
            }
            else
                SSDebug.LogVerbose("Not rolling for enemy #"..unrolled_enemies.." - not valid map or threshold, or exceeded spawn number");
        }
    }
}

//This item signifies that we have a start token, so we can verify that a player has been setup correctly etc
//This also gives us the advantage of "restarting" when on a pistol-start enforced mission, like in scythe2
class NoSaveStartup : SavingModPermanentItem
{
    bool startup;
    
    override void Travelled()
    {
        if (nosave_strip_between_levels)
            owner.TakeInventory("SaveGem",999);
    }

    override void DoEffect()
    {
        //This needs to be delayed by a bit or it doesn't make a save
        if (gametic > 5 && !startup)
        {
            //Do an autosave right at the start of the game, and once only, so that we always have at least one autosave. Otherwise we get bad pistol starts.
            //This also ensures we always have a copy of the Save Gem, even if it has 0 uses
            owner.GiveInventory("SaveGem",1);
            SaveGem savegem = SaveGem(owner.FindInventory("SaveGem",true)); //gross
            owner.UseInventory(savegem);
            
            //Give the rest
            if (nosave_items_starting > 0)
                owner.GiveInventory("SaveGem",nosave_items_starting);
            
            startup = true;
        }
        super.DoEffect();
    }
}
